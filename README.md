# Go语言自学系列

## byte和rune类型
组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（'）包裹起来，如：

```go
package main
 
import "fmt"
 
func main() {
    var a = '华'
    var b = 'a'
    fmt.Printf("a: %v,%c\n", a, a)
    fmt.Printf("b: %v,%c\n", b, b)
}
```

运行结果

```
a: 21326,华
b: 97,a
```

Go 语言的字符有以下两种：

- uint8类型，或者叫 byte 型，代表了ASCII码的一个字符。
    - byte 类似 uint8
- rune类型，代表一个 UTF-8字符。
    - rune 类似 int32
    - 当需要处理中文、日文或者其他复合字符时，则需要用到rune类型。rune类型实际是一个int32。

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

## 占位符
### 整数占位符

| 占位符 |                    说明                    |         举例         |  输出  |
| :----: | :----------------------------------------: | :------------------: | :----: |
|   %b   |                 二进制表示                 |   Printf("%b", 5)    |  101   |
|   %c   |        相应Unicode码点所表示的字符         | Printf("%c", 0x4E2D) |   中   |
|   %d   |                 十进制表示                 |  Printf("%d", 0x12)  |   18   |
|   %o   |                 八进制表示                 |   Printf("%o", 10)   |   12   |
|   %q   | 单引号围绕的字符字面值，由Go语法安全地转义 | Printf("%q", 0x4E2D) |  '中'  |
|   %x   |      十六进制表示，字母形式为小写 a-f      |   Printf("%x", 13)   |   d    |
|   %X   |      十六进制表示，字母形式为大写 A-F      |   Printf("%x", 13)   |   D    |
|   %U   |    Unicode格式：U+1234，等同于 "U+%04X"    | Printf("%U", 0x4E2D) | U+4E2D |

### 浮点数和复数的组成部分（实部和虚部）

| 占位符 |                             说明                             |          举例          |     输出     |
| :----: | :----------------------------------------------------------: | :--------------------: | :----------: |
|   %b   | 无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 'b' 转换格式一致。例如 -123456p-78 |                        |              |
|   %e   |                科学计数法，例如 -1234.456e+78                |   Printf("%e", 10.2)   | 1.020000e+01 |
|   %E   |                科学计数法，例如 -1234.456E+78                |   Printf("%e", 10.2)   | 1.020000E+01 |
|   %f   |                有小数点而无指数，例如 123.456                |   Printf("%f", 10.2)   |  10.200000   |
|   %g   |    根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出     |  Printf("%g", 10.20)   |     10.2     |
|   %G   |    根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出     | Printf("%G", 10.20+2i) |  (10.2+2i)   |

### 字符串与字节切片

| 占位符 |                  说明                  |              举例              |     输出     |
| :----: | :------------------------------------: | :----------------------------: | :----------: |
|   %s   |  输出字符串表示（string类型或[]byte)   | Printf("%s", []byte("多课网")) |    多课网    |
|   %q   | 双引号围绕的字符串，由Go语法安全地转义 |     Printf("%q", "多课网")     |   "多课网"   |
|   %x   |   十六进制，小写字母，每字节两个字符   |     Printf("%x", "golang")     | 676f6c616e67 |
|   %X   |   十六进制，大写字母，每字节两个字符   |     Printf("%X", "golang")     | 676F6C616E67 |

### 指针

| 占位符 |         说明          |        举例         |   输出   |
| :----: | :-------------------: | :-----------------: | :------: |
|   %p   | 十六进制表示，前缀 0x | Printf("%p", &site) | 0x4f57f0 |

## 快捷键
`fint`
`ff`
`fp`
`forr`
`s.print!`
`s.var!`
`pkm`

## go语言类型定义和类型别名的区别
- 类型定义相当于定义了一个全新的类型，与之前的类型不同；但是类型别名并没有定义一个新的类型，而是使用一个别名来替换之前的类型
- 类型别名只会在代码中存在，在编译完成之后并不会存在该别名
- 因为类型别名和原来的类型是一致的，所以原来类型所拥有的方法，类型别名中也可以调用，但是如果是重新定义的一个类型，那么不可以调用之前的任何方法

### go语言类型定义
类型定义的语法

```python
type NewType Type
```

```go
package main
 
import "fmt"
 
func main() {
    // 类型定义
    type MyInt int
    // i为MyInt类型
    var i MyInt
    i = 100
    fmt.Printf("i: %v i: %T\n", i, i)
}

// i: 100 i: main.MyInt
```

### go语言类型别名

类型别名的语法

```python
type NewType = Type
```

```go
package main
 
import "fmt"
 
func main() {
    // 类型别名定义
    type MyInt2 = int
    // i其实还是int类型
    var i MyInt2
    i = 100
    fmt.Printf("i: %v i: %T\n", i, i)
}

// i: 100 i: int
```

